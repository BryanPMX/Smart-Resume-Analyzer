import 'section_score.dart';
import '../services/major_detector.dart';

/// Model class representing a parsed resume with all essential and optional fields.
/// Automatically detects the academic major from the resume text if not provided.
class Resume {
  /// The name of the uploaded PDF file.
  final String fileName;

  /// The raw extracted text from the PDF.
  final String fullText;

  /// Extracted contact information (e.g., email, phone).
  final String? contactInfo;

  /// Professional summary paragraph or section.
  final String? summary;

  /// Full work experience section (plain text).
  final String? experience;

  /// Full education section (plain text).
  final String? education;

  /// A list of individual skill keywords.
  final List<String>? skills;

  /// A list of certifications or achievements.
  final List<String>? certifications;

  /// A list of projects mentioned, if any.
  final List<String>? projects;

  /// The detected academic major inferred from the resume text.
  final String? major;

  /// A score out of 100 assigned to the resume after analysis.
  final int score;

  /// Tips or suggestions generated by the analysis.
  final List<String> feedback;

  /// Breakdown of analysis per section using the SectionScore model.
  final List<SectionScore> sectionBreakdown;

  /// Map of section labels to their extracted text blocks.
  final Map<String, String> parsedSections;

  /// Map of section labels to their character offsets in the full text.
  final Map<String, int> sectionOffsets;

  /// Creates a new [Resume].
  /// If [major] is not provided, it is automatically detected from [fullText].
  Resume({
    required this.fileName,
    required this.fullText,
    this.contactInfo,
    this.summary,
    this.experience,
    this.education,
    this.skills,
    this.certifications,
    this.projects,
    String? major,
    int score = 0,
    List<String>? feedback,
    List<SectionScore>? sectionBreakdown,
    Map<String, String>? parsedSections,
    Map<String, int>? sectionOffsets,
  })  : major = major ?? MajorDetector.detectMajor(fullText),
        score = score,
        feedback = feedback ?? const [],
        sectionBreakdown = sectionBreakdown ?? const [],
        parsedSections = parsedSections ?? const {},
        sectionOffsets = sectionOffsets ?? const {};

  /// Creates an empty [Resume] for initial state.
  factory Resume.empty() => Resume(
    fileName: '',
    fullText: '',
  );

  /// Returns a copy of this resume with updated fields.
  /// Re-runs major detection if [fullText] changes and [major] is not explicitly provided.
  Resume copyWith({
    String? fileName,
    String? fullText,
    String? contactInfo,
    String? summary,
    String? experience,
    String? education,
    List<String>? skills,
    List<String>? certifications,
    List<String>? projects,
    String? major,
    int? score,
    List<String>? feedback,
    List<SectionScore>? sectionBreakdown,
    Map<String, String>? parsedSections,
    Map<String, int>? sectionOffsets,
  }) {
    final updatedText = fullText ?? this.fullText;
    final detectedMajor = major ?? MajorDetector.detectMajor(updatedText) ?? this.major;

    return Resume(
      fileName: fileName ?? this.fileName,
      fullText: updatedText,
      contactInfo: contactInfo ?? this.contactInfo,
      summary: summary ?? this.summary,
      experience: experience ?? this.experience,
      education: education ?? this.education,
      skills: skills ?? this.skills,
      certifications: certifications ?? this.certifications,
      projects: projects ?? this.projects,
      major: detectedMajor,
      score: score ?? this.score,
      feedback: feedback ?? this.feedback,
      sectionBreakdown: sectionBreakdown ?? this.sectionBreakdown,
      parsedSections: parsedSections ?? this.parsedSections,
      sectionOffsets: sectionOffsets ?? this.sectionOffsets,
    );
  }

  /// Debug string.
  @override
  String toString() => 'Resume(fileName: $fileName, score: $score, major: $major)';

  /// Whether the resume has any text content.
  bool get isValid => fullText.trim().isNotEmpty;
}
